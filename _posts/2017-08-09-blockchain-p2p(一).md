---
title: "以太坊中密码学原理(一)"
layout: post
date: 2017-08-29 22:10
tag: 
- 区块链 
- 密码学
image: https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1542007308076&di=771efc26f5d3cc8f12d1428db422595c&imgtype=0&src=http%3A%2F%2Fp0.ifengimg.com%2Fpmop%2F2018%2F0613%2F08825D9DB34DC95D47158B7FD132F3103B0EA908_size61_w580_h330.jpeg
headerImage: true
hidden: false # don't count this post in blog pagination
description: "以太坊密码学原理"
category: blockchain
author: augustus
externalLink: false
---

# 一、非对称加密/解密


## (一)、[问题]非对称加密解决的问题：

秘钥分配问题也就是秘钥的传输问题，如果对称秘钥，那么只能在线下进行秘钥的交换。如果在线上传输秘钥，那就有可能被拦截。所以采用非对称加密，两把钥匙，一把私钥自留，一把公钥公开。公钥可以在网上传输。不用线下交易。



## (二)、[解决方案]公钥私钥加密流程：

       例如，当前节点A 要与集群中节点B进行交互，那么A首先要从自己的公钥库中找到B节点的的公开秘钥(B的公开秘钥谁都可以获取)。然后对要传输的明文信息用B的公钥来加密，然后传输给B 节点。 而B节点则采用自己的私钥(私钥只有自己拥有)解密出数据。流程图如下：



![image.png | left | 791x359]({{ site.url }}/assets/images/cipher/cipher1.png "")


---

## (三)、[问题]基于以上流程遇到的问题？

       此时，虽然明文是可以加密了，但是对于B节点来说，网络上所有的节点都有B节点的公钥，那么在A，B节点交互过程中，B怎么知道接受到的消息是A节点发的呢？有可能是黑客模拟A节点发的也是可能的啊？也就是认证问题。

## (四)、[解决方案]私钥加密流程

       基于(三)中的问题，我们发现用公钥加密，无法解决消息认证的问题。
所以此时，我们用A的私钥进行加密，然后，B节点则可以从自己的私钥库中获取A的公钥然后解密。因为私钥只有A节点有，如果B用A的公钥能解开，说明该消息一定是A发送的，而不是其他人发送的。这样就可以解决了交互中的认证问题。流程图如下：



![image.png | left | 717x279]({{ site.url }}/assets/images/cipher/cipher2.png "")


---



## (五)、[问题]私钥加密流程的问题

       由于A节点发送的消息是采用A的私钥进行加密的，而私钥加密是可以用A的公钥解密的。A的公钥又是公开的，网上所有的人都知道，只要拦截A发送的消息，就能将消息全部解密出来。这样加密就没有意义了。

## (六)、[解决方案]非对称的双重加密

       首先，在A节点发送明文消息之前，首先我们对消息 用B的公钥加密一次(只有B能用私钥解开,解决加密问题)，其次，在用A的私钥对加密后的消息再加密一次(解决认证问题)。而当B接受到消息后，首先用A的公钥解密，能解开则可以确定是A发送过来的消息，然后再用B的私钥将消息解密出来。流程图入下：



![image.png | left | 827x182]({{ site.url }}/assets/images/cipher/cipher3.png "")


---


> 到目前为止就解决了两个问题，一个是解决了加密的问题，另一个是解决了认证问题。

## (七)、[问题]是先私钥加密还是先公钥加密

       如上图，如果先用B的公钥加密，然后在用A的私钥加密， 由于最后一步是采用A的私钥加密的，但是A的公钥所有人都有，所以网络上拦截A的消息后，是可以利用公钥解密出密文数据1的，这样 A私钥机密的那一步就没有用了。这样就可以伪装A节点想B节点发送消息。所以是不安全的。

## (八)、[解决方案]先私钥加密，在公钥加密

       在加密时，先采用A的私钥加密，确认消息是A发送的。然后再用B的公钥加密。这样B 的公钥加密消息只有B能解密，所以即使其他人拦截了该消息，也无法解密出来。流程图如下：



![image.png | left | 827x220]({{ site.url }}/assets/images/cipher/cipher4.png "")



---

# 二、消息认证

## (一)、[问题]为什么要消息认证

对于上述方案，可以解决了加密，解密。但是如果一个黑客拦截了A发送给B 的消息 密文数据2，黑客虽然无法破解，但是黑客将密文数据2中的某个数值随机的改变了，修改完后，B 节点接收到消息，并解密出来，这是解密出来的消息一定不对了。那么如何解决这个问题。

## (二)、[解决方案]Hash认证

       首先我们对消息整体做一个Hash计算，计算出一个散列值，然后将消息+散列值一起发送给B节点，B节点接受到数据后，对原有的数据计算同样的Hash然后跟接收到的散列值比较，如果相同则没有改过，如果不一样说明被篡改过。

       同时不能用明文传输，如果用明文传输，黑客有可能修改了数据，如果还知道你的散列算法，那么还是可以修改拦截到的内容。所以这里散列值 一定是要 采用秘闻传输的。如下图：



![image.png | left | 827x195]({{ site.url }}/assets/images/cipher/cipher5.png "")


## (三)、[问题]对于大数据传输的性能问题

        对于上述流程，如果数据量比较大的情况下，上述的加密过程会显得效率很低下。如何进行不同场景的优化呢？


## (四)、[解决方案]不同场景下加密数据不同

       对于上述的情况，假如传输的数据不是很重要，让网络上其他人看到后不影响，只要不被篡改就可以。那么此时，再进行加密时就可以选择性的加密。

       比如，我们可将原始数据进行hash，得到散列值，然后对散列值进行加密。这样只要保证散列值不被修改，就可以保证在B端接受到数据后，能校验出数据是否被篡改过。
       如果，我们传输的数据机密比较高，则可以将所有的数据都做加密后在传输。


---

# 三、签名

## (一)、[问题]为什么需要签名

        比如A 节点向B 节点发送了一个消息，这个消息后来A节点发现对自己不利，于是否认自己曾经发送过该消息。所以在发送消息时，就需要将A发送的消息打上A自己的烙印，让其无法抵赖。

## (二)、[解决方案]利用私钥对数据进行签名

       在传输过程中，要对发送的消息，用A几点的私钥进行签名，也就是生成一个包含私钥的唯一识别码，这样将该签名发送给B节点，B对签名进行留存。
       签名也是一个HASH值：以太坊中采用了H-MAC模型来签名的。数字签名就是 对 发送的数据先hash生成摘要digest,然后用私钥对digest进行加密，这个加密结果就是数字签名。

*go-以太坊中的签名算法：*

```go
// 然后采用私钥对 该hash加密 --- 注意这里是对hash值 加密得到 签名
sig, err := crypto.Sign(crypto.Keccak256(packet[headSize:]), priv)
```

*java中的签名算法：*
```http
Signature signature = Signature.getInstance("SHA256withECDSA");//采用sha256的椭圆曲线算法
signature.initSign(ecPrivateKey); //私钥签名
signature.update(data.getBytes());
byte[] sign = signature.sign();//得到签名
```


# 四、加密、认证、签名模型

根据上述理论，我们能得到一个整体的加密、数字校验、签名的流程图，如下：



![image.png | left | 827x227]({{ site.url }}/assets/images/cipher/cipher6.png "")


---

上图的流程可以完美解决我们想解决的三个问题，但是有一个性能问题：如果数据传输量较大，并且还用了B的公钥加密，效率十分低下，尤其公钥加密。

所以在实际应用中，如果传输的明文数据不是很重要，那么B的公钥加密那一步可省略。用明文传输 或者结合对称加密传输。

